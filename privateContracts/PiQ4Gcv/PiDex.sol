pragma solidity v0.8;

import {verifiedChain, verifiedToken} from InstilledInteroperability.sol;
import chainlink pricefeeds;

import market endpoints/dexpoints:(

uniswap,
1inch,
vvs finance,
pancakeswap,
aquarius protocol,
nasdaq,
nyse,
);

contract PiDex(msg.sender, verifiedToken, uint256){
async const var PiDex{
function buyCrypto (msg.sender, verifiedToken, uint256){
},
function sellCrypto (msg.sender, verifiedToken, uint256){
},
function swapCrypto (msg.sender, verifiedToken, uint256){
},
function withdrawCrypto (address, bank account, uint256){
},

const variable PiDex[Ethereum]:(
function swapCrypto (msg.sender, verifiedToken, uint256){
},
url:(
uniswap.com,
1inch.com,
dydx.com,
oceanprotocol.com,
),
verifiedTokens:(
(ethereum, 0x000),
(uniswap, 0x...),
(chainlink, 0x...)
),
),

const variable PiDex[Binance]:(),

const variable PiDex[Stellar]:(),

const variable PiDex[Bitcoin]:(),

const variable PiDex[Chain]:(
function swap,
dex urls,
tokens available on that chain/ verifiedTokens,
)

} 


const crosschain swaps:(
PiDex(native),
PiDex(Ethereum),
PiDex(Binance),
PiDex(Stellar),
PiDex(Arbitrum),
PiDex(Solana),
PiDex(Bitcoin),
PiDex(Cronos),

if swap(verifiedToken, verifiedChain) != receive(verifiedChain),
then return function crosschainSwap;

function crosschainSwap(msg.sender, verifiedToken, uint256){
if msg.sender swaps(Pi, Pi(native)) to receive(Bitcoin, bitcoin blockchain),
then:(
sell Pi to $amountUSD,
$amountUSD to buy $btc,
then transfer $btc to msg.sender,

const variable PiDex[Pi (native)]:(
function crosschainSwap,
dex urls,
tokens available on that chain/ verifiedTokens,
)

}


if verifiedChain != verifiedToken them returm error('That token is not available on this chain'),

)
}
